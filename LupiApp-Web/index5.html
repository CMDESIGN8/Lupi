<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lupi Game ‚Äî Versi√≥n Mejorada</title>

<!-- three.js primero -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- loaders (GLTF) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

<style>
  :root{
    --bg:#070712; 
    --accent:#00ff88;
    --accent2:#00aaff;
    --pink:#b02cff;
    --gold:#ffd700;
    --hud-bg:rgba(0,0,0,0.7);
  }
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  
  html, body {
    height: 100%;
    background: var(--bg);
    color: #fff;
    overflow: hidden;
    touch-action: none;
  }
  
  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
  
  /* Pantalla de inicio */
  #startScreen {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    background: linear-gradient(135deg, #0a0a1a, #1a1a2a);
    flex-direction: column;
    gap: 20px;
  }
  
  .game-title {
    font-size: 4rem;
    font-weight: 900;
    background: linear-gradient(90deg, var(--accent), var(--accent2), var(--pink));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
    margin-bottom: 10px;
    animation: titleGlow 3s infinite alternate;
  }
  
  .start-buttons {
    display: flex;
    gap: 15px;
    margin-top: 20px;
  }
  
  .btn {
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    border: none;
    padding: 12px 24px;
    border-radius: 50px;
    cursor: pointer;
    font-weight: 700;
    color: #001;
    transition: all 0.3s ease;
    box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
  }
  
  .btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
  }
  
  /* HUD mejorado */
  #hud {
    position: absolute;
    left: 20px;
    top: 20px;
    z-index: 50;
    background: var(--hud-bg);
    padding: 15px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    min-width: 250px;
  }
  
  .hud-section {
    margin-bottom: 15px;
  }
  
  .hud-section:last-child {
    margin-bottom: 0;
  }
  
  .hud-title {
    font-size: 0.9rem;
    color: #aaa;
    margin-bottom: 5px;
  }
  
  .hud-value {
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--accent);
    text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
  }
  
  .xp-bar {
    width: 100%;
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    margin-top: 5px;
    overflow: hidden;
  }
  
  .xp-progress {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    width: 0%;
    border-radius: 4px;
    transition: width 0.5s ease;
    position: relative;
  }
  
  .xp-progress::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    animation: shimmer 2s infinite;
  }
  
  /* Panel de misi√≥n */
  #missionPanel {
    position: absolute;
    right: 20px;
    top: 20px;
    z-index: 50;
    background: var(--hud-bg);
    padding: 15px;
    border-radius: 15px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(176, 44, 255, 0.3);
    max-width: 300px;
  }
  
  .mission-title {
    font-size: 1rem;
    color: var(--pink);
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 5px;
  }
  
  .mission-progress {
    width: 100%;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    margin: 8px 0;
    overflow: hidden;
  }
  
  .mission-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--pink), var(--accent2));
    width: 0%;
    border-radius: 3px;
    transition: width 0.5s ease;
  }
  
  .mission-reward {
    font-size: 0.9rem;
    color: var(--gold);
    display: flex;
    align-items: center;
    gap: 5px;
  }
  
  /* Indicadores de poder */
  #powerIndicator {
    position: absolute;
    bottom: 20px;
    left: 20px;
    z-index: 50;
    background: var(--hud-bg);
    padding: 10px 15px;
    border-radius: 10px;
    backdrop-filter: blur(10px);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  
  .power-bar {
    width: 100px;
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    overflow: hidden;
  }
  
  .power-progress {
    height: 100%;
    background: linear-gradient(90deg, #ff4444, #ffaa00);
    width: 100%;
    border-radius: 4px;
    transition: width 0.3s ease;
  }
  
  /* Joystick m√≥vil */
  #mobileControls {
    position: absolute;
    left: 20px;
    bottom: 80px;
    width: 140px;
    height: 140px;
    z-index: 40;
    display: none;
    touch-action: none;
  }
  
  #joystickBase {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.05);
    position: relative;
    border: 2px solid rgba(255, 255, 255, 0.1);
  }
  
  #joystickKnob {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.1);
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    border: 2px solid rgba(255, 255, 255, 0.2);
    transition: transform 0.1s ease;
  }
  
  /* Notificaciones */
  .notification {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.8);
    padding: 20px 30px;
    border-radius: 15px;
    border: 2px solid var(--accent);
    z-index: 60;
    text-align: center;
    display: none;
    backdrop-filter: blur(10px);
    box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
    animation: fadeIn 0.5s ease;
  }
  
  .notification-title {
    font-size: 1.5rem;
    color: var(--accent);
    margin-bottom: 10px;
  }
  
  /* Efectos de part√≠culas en la UI */
  .particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: var(--accent);
    border-radius: 50%;
    pointer-events: none;
    opacity: 0;
  }
  
  /* Animaciones */
  @keyframes titleGlow {
    0% { text-shadow: 0 0 30px rgba(0, 255, 136, 0.3); }
    100% { text-shadow: 0 0 50px rgba(0, 170, 255, 0.6), 0 0 70px rgba(176, 44, 255, 0.4); }
  }
  
  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }
  
  @keyframes fadeIn {
    from { opacity: 0; transform: translate(-50%, -40%); }
    to { opacity: 1; transform: translate(-50%, -50%); }
  }
  
  @keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    #mobileControls {
      display: block;
    }
    
    #hud, #missionPanel {
      padding: 10px;
      min-width: auto;
    }
    
    .game-title {
      font-size: 2.5rem;
    }
    
    .start-buttons {
      flex-direction: column;
    }
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<!-- Pantalla de inicio -->
<div id="startScreen">
  <div style="text-align: center; max-width: 600px; padding: 20px;">
    <h1 class="game-title">LUPI GAME</h1>
    <p style="color: #ddd; margin-bottom: 30px; line-height: 1.5;">
      Emb√°rcate en una aventura √©pica para transformar clubes de barrio en comunidades vibrantes. 
      Recolecta Lupicoins, completa misiones y desbloquea poderes especiales.
    </p>
    
    <div class="start-buttons">
      <button class="btn" id="startBtn">INICIAR AVENTURA (PC)</button>
      <button class="btn" id="startBtnMobile">INICIAR AVENTURA (M√ìVIL)</button>
    </div>
    
    <div style="margin-top: 30px; color: #888; font-size: 0.9rem;">
      <p>Controles PC: WASD para mover, rat√≥n para mirar</p>
      <p>Controles M√≥vil: Usa el joystick virtual</p>
    </div>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div class="hud-section">
    <div class="hud-title">NIVEL</div>
    <div class="hud-value" id="level">1</div>
  </div>
  
  <div class="hud-section">
    <div class="hud-title">LUPICOINS</div>
    <div class="hud-value" id="lupicoins">0</div>
  </div>
  
  <div class="hud-section">
    <div class="hud-title">EXPERIENCIA</div>
    <div class="xp-bar">
      <div class="xp-progress" id="xpProgress"></div>
    </div>
    <div style="font-size: 0.8rem; color: #aaa; margin-top: 3px;">
      <span id="xpCurrent">0</span> / <span id="xpNeeded">100</span> XP
    </div>
  </div>
</div>

<!-- Panel de misi√≥n -->
<div id="missionPanel">
  <div class="mission-title">üéØ MISI√ìN ACTUAL</div>
  <div id="missionObjective" style="color: #ddd; font-size: 0.9rem;">
    Recolecta 5 Lupicoins para comenzar
  </div>
  <div class="mission-progress">
    <div class="mission-progress-bar" id="missionProgress"></div>
  </div>
  <div class="mission-reward">
    <span>üéÅ Recompensa:</span>
    <span id="missionReward">+100 Lupicoins</span>
  </div>
</div>

<!-- Indicador de poder -->
<div id="powerIndicator">
  <div style="color: #fff; font-size: 0.9rem;">PODER</div>
  <div class="power-bar">
    <div class="power-progress" id="powerProgress"></div>
  </div>
</div>

<!-- Joystick m√≥vil -->
<div id="mobileControls">
  <div id="joystickBase">
    <div id="joystickKnob"></div>
  </div>
</div>

<!-- Notificaci√≥n -->
<div class="notification" id="notification">
  <div class="notification-title" id="notificationTitle">¬°Bienvenido!</div>
  <div id="notificationText">Comienza tu aventura recolectando Lupicoins</div>
  <button class="btn" style="margin-top: 15px;" onclick="hideNotification()">Continuar</button>
</div>

<script>
/* ============================
   LUPI GAME - VERSI√ìN MEJORADA
   ============================ */

// Variables globales
let scene, camera, renderer, clock;
let playerGroup, lupiModel = null;
let collectibles = [], obstacles = [], enemies = [], powerUps = [];
let isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
let gameStarted = false;
let gamePaused = false;

// Sistema de movimiento
const move = { f:0, b:0, l:0, r:0 };
let joystickActive = false, joystickDir = {x:0,y:0};

// Sistema de c√°mara
const camOffset = new THREE.Vector3(0, 1.6, 3.2);
let camYaw = 0, camPitch = 0;
let cameraShake = 0;

// Sistema de juego
const gameState = {
  level: 1,
  xp: 0,
  xpNeeded: 100,
  lupicoins: 0,
  power: 100,
  maxPower: 100,
  combo: 0,
  comboMultiplier: 1,
  comboTimeout: null
};

// Sistema de misiones
const missions = [
  {
    id: 1,
    title: "Primeros Pasos",
    objective: "Recolecta 5 Lupicoins",
    target: 5,
    progress: 0,
    reward: 100,
    completed: false,
    type: "collection"
  },
  {
    id: 2,
    title: "Explorador Novato",
    objective: "Recolecta 20 Lupicoins",
    target: 20,
    progress: 0,
    reward: 300,
    completed: false,
    type: "collection"
  },
  {
    id: 3,
    title: "Cazador de Obst√°culos",
    objective: "Destruye 5 obst√°culos",
    target: 5,
    progress: 0,
    reward: 500,
    completed: false,
    type: "obstacles"
  },
  {
    id: 4,
    title: "Maestro de Lupi",
    objective: "Alcanza el nivel 5",
    target: 5,
    progress: 1,
    reward: 1000,
    completed: false,
    type: "level"
  }
];

let currentMissionIndex = 0;

// Efectos de part√≠culas
let particleSystems = [];

// Inicializar la escena
function initScene() {
  // Crear escena
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);
  scene.fog = new THREE.Fog(0x0a0a1a, 10, 100);
  clock = new THREE.Clock();

  // Crear c√°mara
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 3.2);
  camera.lookAt(0, 0, 0);

  // Crear renderer
  renderer = new THREE.WebGLRenderer({ 
    canvas: document.getElementById('gameCanvas'), 
    antialias: true,
    alpha: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;

  // Configurar iluminaci√≥n
  setupLighting();
  
  // Crear terreno
  createTerrain();
  
  // Crear entorno
  createEnvironment();
  
  // Crear grupo del jugador
  playerGroup = new THREE.Group();
  playerGroup.position.set(0, 0, 0);
  scene.add(playerGroup);

  // Cargar modelo de Lupi
  loadLupiModel();
  
  // Crear objetos del juego
  createCollectibles(25);
  createObstacles(15);
  createPowerUps(5);
  
  // Configurar eventos
  window.addEventListener('resize', onResize);
  setupControls();
  
  // Mostrar controles m√≥viles si es necesario
  if (isTouch) {
    document.getElementById('mobileControls').style.display = 'block';
  }
  
  // Iniciar animaci√≥n
  animate();
}

// Configurar iluminaci√≥n mejorada
function setupLighting() {
  // Luz ambiental
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
  scene.add(ambientLight);
  
  // Luz direccional principal
  const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
  mainLight.position.set(10, 15, 10);
  mainLight.castShadow = true;
  mainLight.shadow.mapSize.width = 2048;
  mainLight.shadow.mapSize.height = 2048;
  mainLight.shadow.camera.near = 0.5;
  mainLight.shadow.camera.far = 50;
  mainLight.shadow.camera.left = -20;
  mainLight.shadow.camera.right = 20;
  mainLight.shadow.camera.top = 20;
  mainLight.shadow.camera.bottom = -20;
  scene.add(mainLight);
  
  // Luz de relleno
  const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
  fillLight.position.set(-10, 5, -10);
  scene.add(fillLight);
  
  // Luz de acento
  const accentLight = new THREE.PointLight(0x00ff88, 0.5, 20);
  accentLight.position.set(0, 5, 0);
  scene.add(accentLight);
}

// Crear terreno con textura de pasto
function createTerrain() {
    // Geometr√≠a grande para el terreno
    const terrainGeometry = new THREE.PlaneGeometry(200, 200, 200, 200);

    // Crear colinas suaves
    const vertices = terrainGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
        const x = vertices[i];
        const z = vertices[i + 2];
        vertices[i + 1] = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 3;
    }
    terrainGeometry.computeVertexNormals();

    // Cargar texturas
    const loader = new THREE.TextureLoader();
loader.load('textures/grass.jpg', (texture) => {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(30, 30);
    texture.encoding = THREE.sRGBEncoding;

    const material = new THREE.MeshStandardMaterial({ map: texture });
    const geometry = new THREE.PlaneGeometry(200, 200, 200, 200);
    const terrain = new THREE.Mesh(geometry, material);
    terrain.rotation.x = -Math.PI / 2;
    terrain.position.y = 0;
    scene.add(terrain);
});

    // Pasto
    const grassTexture = loader.load("textures/grass.jpg", (texture) => {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(30, 30);
        texture.encoding = THREE.sRGBEncoding;
    });

    // Opcional: normal map para relieve
    const normalTexture = loader.load("textures/grass_normal.jpg", (texture) => {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    });

    // Material con textura y normal map
    const terrainMaterial = new THREE.MeshStandardMaterial({
        map: grassTexture,
        normalMap: normalTexture,
        side: THREE.DoubleSide
    });

    // Crear mesh del terreno
    const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
    terrain.rotation.x = -Math.PI / 2; // horizontal
    terrain.position.y = -0.5;
    terrain.receiveShadow = true;

    // Agregar a la escena
    scene.add(terrain);
}



// Crear entorno
function createEnvironment() {
  // Crear estadio central
  const stadiumGeometry = new THREE.CylinderGeometry(8, 10, 3, 32);
  const stadiumMaterial = new THREE.MeshStandardMaterial({
    color: 0x2db82d,
    roughness: 0.6,
    metalness: 0.2
  });
  const stadium = new THREE.Mesh(stadiumGeometry, stadiumMaterial);
  stadium.position.set(0, 1.5, 0);
  stadium.castShadow = true;
  stadium.receiveShadow = true;
  scene.add(stadium);
  
  // Crear edificios
  for (let i = 0; i < 20; i++) {
    const height = 3 + Math.random() * 8;
    const buildingGeometry = new THREE.BoxGeometry(3, height, 3);
    const buildingMaterial = new THREE.MeshStandardMaterial({
      color: 0x5555aa + Math.random() * 0x444444,
      roughness: 0.5,
      metalness: 0.1
    });
    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
    
    const angle = (i / 20) * Math.PI * 2;
    const radius = 20 + Math.random() * 10;
    building.position.set(
      Math.cos(angle) * radius,
      height / 2,
      Math.sin(angle) * radius
    );
    building.castShadow = true;
    building.receiveShadow = true;
    scene.add(building);
  }
  
  // Crear sistema de part√≠culas ambiental
  createAmbientParticles();
}

// Crear part√≠culas ambientales
function createAmbientParticles() {
  const particleCount = 200;
  const particles = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  const colors = new Float32Array(particleCount * 3);
  
  for (let i = 0; i < particleCount * 3; i += 3) {
    positions[i] = (Math.random() - 0.5) * 100;
    positions[i + 1] = Math.random() * 20;
    positions[i + 2] = (Math.random() - 0.5) * 100;
    
    // Colores entre azul y verde
    colors[i] = Math.random() * 0.5;
    colors[i + 1] = 0.5 + Math.random() * 0.5;
    colors[i + 2] = 0.5 + Math.random() * 0.5;
  }
  
  particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  const particleMaterial = new THREE.PointsMaterial({
    size: 0.1,
    vertexColors: true,
    transparent: true,
    opacity: 0.6
  });
  
  const particleSystem = new THREE.Points(particles, particleMaterial);
  scene.add(particleSystem);
  particleSystems.push(particleSystem);
}

// Cargar modelo de Lupi
function loadLupiModel() {
  const loader = new THREE.GLTFLoader();
  
  // Intentar cargar el modelo
  loader.load('lupi1.glb', (gltf) => {
    // Eliminar modelo anterior si existe
    if (lupiModel) {
      playerGroup.remove(lupiModel);
    }
    
    lupiModel = gltf.scene;
    
    // Configurar sombras y materiales
    lupiModel.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        
        if (child.material) {
          // Mejorar materiales si es necesario
          if (child.material.map) {
            child.material.map.encoding = THREE.sRGBEncoding;
          }
          child.material.metalness = 0.2;
          child.material.roughness = 0.7;
        }
      }
    });
    
    // Ajustar escala y posici√≥n
    const bbox = new THREE.Box3().setFromObject(lupiModel);
    const size = new THREE.Vector3();
    bbox.getSize(size);
    
    const targetHeight = 1.8;
    const scale = targetHeight / size.y;
    lupiModel.scale.setScalar(scale);
    
    // Centrar y posicionar
    const center = new THREE.Vector3();
    bbox.getCenter(center);
    lupiModel.position.sub(center);
    lupiModel.position.y = size.y * 0.5 * scale;
    
    playerGroup.add(lupiModel);
    console.log('Modelo de Lupi cargado correctamente');
    
  }, undefined, (error) => {
    console.error('Error cargando el modelo:', error);
    // Crear un modelo de respaldo si falla la carga
    createFallbackModel();
  });
}

// Crear modelo de respaldo
function createFallbackModel() {
  const geometry = new THREE.ConeGeometry(0.5, 1.5, 8);
  const material = new THREE.MeshStandardMaterial({
    color: 0x00aaff,
    emissive: 0x004477,
    metalness: 0.3,
    roughness: 0.4
  });
  
  lupiModel = new THREE.Mesh(geometry, material);
  lupiModel.castShadow = true;
  lupiModel.position.y = 0.75;
  
  playerGroup.add(lupiModel);
  console.log('Modelo de respaldo creado');
}

// Crear coleccionables
function createCollectibles(count) {
  const geometry = new THREE.SphereGeometry(0.3, 12, 12);
  
  for (let i = 0; i < count; i++) {
    const material = new THREE.MeshStandardMaterial({
      color: 0xffd700,
      emissive: 0x442200,
      metalness: 0.4,
      roughness: 0.3,
      emissiveIntensity: 0.5
    });
    
    const collectible = new THREE.Mesh(geometry, material);
    
    // Posicionar en un √°rea aleatoria pero accesible
    const angle = Math.random() * Math.PI * 2;
    const radius = 10 + Math.random() * 30;
    collectible.position.set(
      Math.cos(angle) * radius,
      0.3,
      Math.sin(angle) * radius
    );
    
    collectible.castShadow = true;
    collectible.userData = {
      type: 'collectible',
      value: 1,
      collected: false,
      spinSpeed: 1 + Math.random() * 2
    };
    
    scene.add(collectible);
    collectibles.push(collectible);
  }
}

// Crear obst√°culos
function createObstacles(count) {
  for (let i = 0; i < count; i++) {
    const size = 1 + Math.random() * 2;
    const geometry = new THREE.BoxGeometry(size, size, size);
    const material = new THREE.MeshStandardMaterial({
      color: 0xaa4444,
      roughness: 0.8,
      metalness: 0.1
    });
    
    const obstacle = new THREE.Mesh(geometry, material);
    
    const angle = Math.random() * Math.PI * 2;
    const radius = 15 + Math.random() * 25;
    obstacle.position.set(
      Math.cos(angle) * radius,
      size / 2,
      Math.sin(angle) * radius
    );
    
    obstacle.castShadow = true;
    obstacle.receiveShadow = true;
    obstacle.userData = {
      type: 'obstacle',
      damage: 10 + Math.floor(Math.random() * 20),
      health: 3
    };
    
    scene.add(obstacle);
    obstacles.push(obstacle);
  }
}

// Crear power-ups
function createPowerUps(count) {
  const geometry = new THREE.OctahedronGeometry(0.4, 0);
  
  for (let i = 0; i < count; i++) {
    const material = new THREE.MeshStandardMaterial({
      color: 0xb02cff,
      emissive: 0x330066,
      metalness: 0.5,
      roughness: 0.3,
      emissiveIntensity: 0.7
    });
    
    const powerUp = new THREE.Mesh(geometry, material);
    
    const angle = Math.random() * Math.PI * 2;
    const radius = 5 + Math.random() * 35;
    powerUp.position.set(
      Math.cos(angle) * radius,
      0.4,
      Math.sin(angle) * radius
    );
    
    powerUp.castShadow = true;
    powerUp.userData = {
      type: 'powerup',
      effect: ['speed', 'magnet', 'shield'][Math.floor(Math.random() * 3)],
      collected: false
    };
    
    scene.add(powerUp);
    powerUps.push(powerUp);
  }
}

// Configurar controles - CORREGIDO: Movimiento no invertido
function setupControls() {
  // Controles de teclado
  window.addEventListener('keydown', (e) => {
    if (!gameStarted || gamePaused) return;
    
    switch(e.code) {
      case 'KeyW': move.f = 1; break;
      case 'KeyS': move.b = 1; break;
      case 'KeyA': move.r = 1; break;
      case 'KeyD': move.l = 1; break;
      case 'Space': usePower(); break;
      case 'Escape': togglePause(); break;
    }
  });
  
  window.addEventListener('keyup', (e) => {
    if (!gameStarted || gamePaused) return;
    
    switch(e.code) {
      case 'KeyW': move.f = 0; break;
      case 'KeyS': move.b = 0; break;
      case 'KeyA': move.r = 0; break;
      case 'KeyD': move.l = 0; break;
    }
  });
  
  // Controles de rat√≥n
  let mouseDown = false, lastMouseX = 0, lastMouseY = 0;
  
  document.addEventListener('mousedown', (e) => {
    if (!gameStarted || gamePaused) return;
    mouseDown = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  });
  
  document.addEventListener('mouseup', () => {
    mouseDown = false;
  });
  
  document.addEventListener('mousemove', (e) => {
    if (!mouseDown || !gameStarted || gamePaused) return;
    
    const deltaX = e.clientX - lastMouseX;
    const deltaY = e.clientY - lastMouseY;
    
    camYaw -= deltaX * 0.005;
    camPitch = Math.max(-0.8, Math.min(0.8, camPitch - deltaY * 0.005));
    
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  });
  
  // Joystick m√≥vil - CORREGIDO: Movimiento no invertido
  const joystickBase = document.getElementById('joystickBase');
  const joystickKnob = document.getElementById('joystickKnob');
  
  if (joystickBase) {
    let activeTouchId = null;
    
    joystickBase.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      joystickActive = true;
      activeTouchId = e.pointerId;
      joystickBase.setPointerCapture(activeTouchId);
    });
    
    joystickBase.addEventListener('pointermove', (e) => {
      if (!joystickActive || e.pointerId !== activeTouchId) return;
      
      const rect = joystickBase.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      const deltaX = e.clientX - centerX;
      const deltaY = e.clientY - centerY;
      
      const distance = Math.min(50, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
      const angle = Math.atan2(deltaY, deltaX);
      
      // CORRECCI√ìN: Movimiento no invertido
      joystickDir.x = -(distance / 50) * Math.cos(angle);
      joystickDir.y = -(distance / 50) * Math.sin(angle);
      
      joystickKnob.style.transform = `translate(${deltaX * 0.7}px, ${deltaY * 0.7}px)`;
    });
    
    joystickBase.addEventListener('pointerup', (e) => {
      if (e.pointerId !== activeTouchId) return;
      
      joystickActive = false;
      joystickDir.x = 0;
      joystickDir.y = 0;
      joystickKnob.style.transform = 'translate(0, 0)';
      joystickBase.releasePointerCapture(activeTouchId);
      activeTouchId = null;
    });
  }
}

// Usar poder especial
function usePower() {
  if (gameState.power < 20) {
    showNotification("Poder Insuficiente", "Necesitas al menos 20% de poder para usar habilidades especiales");
    return;
  }
  
  gameState.power -= 20;
  updateHUD();
  
  // Efecto visual de poder
  cameraShake = 0.5;
  
  // Atraer coleccionables cercanos
  const playerPos = playerGroup.position;
  let attracted = 0;
  
  collectibles.forEach(collectible => {
    if (collectible.userData.collected) return;
    
    const distance = collectible.position.distanceTo(playerPos);
    if (distance < 10) {
      // Mover hacia el jugador
      const direction = new THREE.Vector3()
        .subVectors(playerPos, collectible.position)
        .normalize();
      
      collectible.position.addScaledVector(direction, 0.3);
      attracted++;
    }
  });
  
  if (attracted > 0) {
    showNotification("¬°Poder de Atracci√≥n!", `Atrayendo ${attracted} Lupicoins`);
  }
}

// Actualizar c√°mara
function updateCamera(delta) {
  const playerPos = playerGroup.position.clone();
  
  // Calcular offset de c√°mara con rotaci√≥n
  const offset = camOffset.clone();
  const cosYaw = Math.cos(camYaw);
  const sinYaw = Math.sin(camYaw);
  
  const rotatedOffset = new THREE.Vector3(
    offset.x * cosYaw - offset.z * sinYaw,
    offset.y + Math.sin(camPitch) * 2,
    offset.x * sinYaw + offset.z * cosYaw
  );
  
  // Posici√≥n deseada de la c√°mara
  const desiredPos = playerPos.clone().add(rotatedOffset);
  
  // Aplicar suavizado y vibraci√≥n
  if (cameraShake > 0) {
    desiredPos.x += (Math.random() - 0.5) * cameraShake;
    desiredPos.y += (Math.random() - 0.5) * cameraShake;
    desiredPos.z += (Math.random() - 0.5) * cameraShake;
    cameraShake -= delta * 2;
  }
  
  camera.position.lerp(desiredPos, 0.1);
  camera.lookAt(playerPos.x, playerPos.y + 1, playerPos.z);
}

// Actualizar jugador - CORREGIDO: Movimiento no invertido
function updatePlayer(delta) {
  // Calcular direcci√≥n de movimiento
  let inputX = move.r - move.l;
  let inputZ = move.f - move.b;
  
  if (joystickActive) {
    inputX = joystickDir.x;
    inputZ = joystickDir.y;
  }
  
  // Salir si no hay entrada
  if (Math.abs(inputX) < 0.01 && Math.abs(inputZ) < 0.01) {
    // Animaci√≥n de idle si est√° disponible
    if (lupiModel) {
      lupiModel.rotation.y += delta * 0;
    }
    return;
  }
  
  // Calcular direcci√≥n basada en la c√°mara
  const cameraDirection = new THREE.Vector3();
  camera.getWorldDirection(cameraDirection);
  cameraDirection.y = 0;
  cameraDirection.normalize();
  
  const cameraRight = new THREE.Vector3()
    .crossVectors(new THREE.Vector3(0, 1, 0), cameraDirection)
    .normalize();
  
  // Vector de movimiento - CORRECCI√ìN: Movimiento no invertido
  const moveDirection = new THREE.Vector3();
  moveDirection.addScaledVector(cameraDirection, inputZ);
  moveDirection.addScaledVector(cameraRight, inputX);
  
  if (moveDirection.length() > 0.01) {
    moveDirection.normalize();
  }
  
  // Aplicar movimiento
  const speed = 5.0 * (gameState.comboMultiplier > 1 ? 1.2 : 1.0);
  playerGroup.position.addScaledVector(moveDirection, speed * delta);
  
  // Rotar modelo hacia la direcci√≥n de movimiento
  if (lupiModel && moveDirection.length() > 0.1) {
    const targetPosition = playerGroup.position.clone().add(moveDirection);
    lupiModel.lookAt(targetPosition.x, playerGroup.position.y, targetPosition.z);
    
    // Animaci√≥n de movimiento
    lupiModel.rotation.y += Math.sin(performance.now() * 0.01) * 0.1;
  }
}

// Verificar colisiones
function checkCollisions() {
  const playerPos = playerGroup.position;
  
  // Coleccionables
  collectibles.forEach(collectible => {
    if (collectible.userData.collected) return;
    
    const distance = collectible.position.distanceTo(playerPos);
    if (distance < 1.0) {
      collectible.userData.collected = true;
      scene.remove(collectible);
      
      // Actualizar estado del juego
      gameState.lupicoins += collectible.userData.value * gameState.comboMultiplier;
      gameState.xp += 10 * gameState.comboMultiplier;
      
      // Combo system
      gameState.combo++;
      updateCombo();
      
      // Actualizar misi√≥n
      updateMissionProgress('collection', collectible.userData.value);
      
      // Efectos visuales y de sonido
      createCollectEffect(collectible.position);
      playSound('collect');
      
      // Actualizar HUD
      updateHUD();
      showFloatingText("+1 Lupicoin", collectible.position);
    }
  });
  
  // Obst√°culos
  obstacles.forEach(obstacle => {
    const distance = obstacle.position.distanceTo(playerPos);
    const obstacleSize = (obstacle.geometry.parameters.width || 1) / 2;
    
    if (distance < obstacleSize + 0.8) {
      // Da√±o al jugador
      gameState.power = Math.max(0, gameState.power - obstacle.userData.damage * 0.01);
      
      // Empujar al jugador
      const pushDirection = new THREE.Vector3()
        .subVectors(playerPos, obstacle.position)
        .setY(0)
        .normalize()
        .multiplyScalar(0.8);
      
      playerGroup.position.add(pushDirection);
      
      // Da√±ar obst√°culo
      obstacle.userData.health--;
      
      if (obstacle.userData.health <= 0) {
        // Destruir obst√°culo
        scene.remove(obstacle);
        updateMissionProgress('obstacles', 1);
        createExplosionEffect(obstacle.position);
        playSound('explosion');
      } else {
        // Efecto de golpe
        createHitEffect(obstacle.position);
        playSound('hit');
      }
      
      // Vibraci√≥n de c√°mara
      cameraShake = 0.3;
      
      // Mostrar notificaci√≥n
      showFloatingText(`-${obstacle.userData.damage}% Poder`, obstacle.position);
      
      updateHUD();
    }
  });
  
  // Power-ups
  powerUps.forEach(powerUp => {
    if (powerUp.userData.collected) return;
    
    const distance = powerUp.position.distanceTo(playerPos);
    if (distance < 1.0) {
      powerUp.userData.collected = true;
      scene.remove(powerUp);
      
      // Aplicar efecto
      applyPowerUpEffect(powerUp.userData.effect);
      
      // Efectos visuales
      createPowerUpEffect(powerUp.position);
      playSound('powerup');
      
      showNotification("¬°Power-up!", `Obtuviste: ${powerUp.userData.effect.toUpperCase()}`);
      updateHUD();
    }
  });
}

// Actualizar sistema de combo
function updateCombo() {
  // Reiniciar timeout del combo
  if (gameState.comboTimeout) {
    clearTimeout(gameState.comboTimeout);
  }
  
  // Calcular multiplicador
  gameState.comboMultiplier = 1 + Math.floor(gameState.combo / 5);
  
  // Timeout para perder el combo
  gameState.comboTimeout = setTimeout(() => {
    if (gameState.combo > 5) {
      showNotification("Combo Perdido", `Combo de ${gameState.combo} Lupicoins`);
    }
    gameState.combo = 0;
    gameState.comboMultiplier = 1;
    updateHUD();
  }, 5000);
  
  // Mostrar notificaci√≥n de combo cada 5
  if (gameState.combo > 0 && gameState.combo % 5 === 0) {
    showNotification(`¬°Combo x${gameState.comboMultiplier}!`, `Multiplicador activo`);
  }
  
  updateHUD();
}

// Aplicar efecto de power-up
function applyPowerUpEffect(effect) {
  switch(effect) {
    case 'speed':
      // Aumentar velocidad temporalmente
      setTimeout(() => {
        showNotification("Velocidad Normal", "El efecto de velocidad ha terminado");
      }, 10000);
      break;
      
    case 'magnet':
      // Atraer coleccionables por un tiempo
      const magnetInterval = setInterval(() => {
        const playerPos = playerGroup.position;
        let attracted = 0;
        
        collectibles.forEach(collectible => {
          if (collectible.userData.collected) return;
          
          const distance = collectible.position.distanceTo(playerPos);
          if (distance < 8) {
            const direction = new THREE.Vector3()
              .subVectors(playerPos, collectible.position)
              .normalize();
            
            collectible.position.addScaledVector(direction, 0.5);
            attracted++;
          }
        });
        
        if (attracted === 0) {
          clearInterval(magnetInterval);
        }
      }, 100);
      
      setTimeout(() => {
        clearInterval(magnetInterval);
        showNotification("Im√°n Desactivado", "El efecto im√°n ha terminado");
      }, 8000);
      break;
      
    case 'shield':
      // Reducir da√±o por un tiempo
      gameState.power = Math.min(gameState.maxPower, gameState.power + 30);
      setTimeout(() => {
        showNotification("Escudo Desactivado", "La protecci√≥n adicional ha terminado");
      }, 15000);
      break;
  }
}

// Actualizar progreso de misi√≥n
function updateMissionProgress(type, amount) {
  const mission = missions[currentMissionIndex];
  if (!mission || mission.completed) return;
  
  if (mission.type === type) {
    mission.progress += amount;
    
    // Actualizar UI
    const progressBar = document.getElementById('missionProgress');
    const progressPercent = (mission.progress / mission.target) * 100;
    progressBar.style.width = `${progressPercent}%`;
    
    // Completar misi√≥n
    if (mission.progress >= mission.target) {
      mission.completed = true;
      completeMission(mission);
    }
  }
  
  // Misi√≥n de nivel
  if (type === 'level') {
    missions.forEach(m => {
      if (m.type === 'level' && !m.completed) {
        m.progress = gameState.level;
        
        const progressBar = document.getElementById('missionProgress');
        const progressPercent = (m.progress / m.target) * 100;
        progressBar.style.width = `${progressPercent}%`;
        
        if (m.progress >= m.target) {
          m.completed = true;
          completeMission(m);
        }
      }
    });
  }
}

// Completar misi√≥n
function completeMission(mission) {
  // Recompensa
  gameState.lupicoins += mission.reward;
  gameState.xp += mission.reward * 0.5;
  
  // Mostrar notificaci√≥n
  showNotification("¬°Misi√≥n Completada!", `${mission.title} - Recompensa: ${mission.reward} Lupicoins`);
  
  // Avanzar a la siguiente misi√≥n
  const nextMissionIndex = missions.findIndex(m => !m.completed);
  if (nextMissionIndex !== -1) {
    currentMissionIndex = nextMissionIndex;
    updateMissionUI();
  } else {
    // Todas las misiones completadas
    showNotification("¬°Felicidades!", "Has completado todas las misiones");
  }
  
  // Verificar subida de nivel
  checkLevelUp();
  updateHUD();
}

// Verificar subida de nivel
function checkLevelUp() {
  if (gameState.xp >= gameState.xpNeeded) {
    gameState.level++;
    gameState.xp -= gameState.xpNeeded;
    gameState.xpNeeded = Math.floor(gameState.xpNeeded * 1.3);
    gameState.power = gameState.maxPower;
    
    // Actualizar misi√≥n de nivel
    updateMissionProgress('level', 0);
    
    showNotification("¬°Subiste de Nivel!", `Ahora eres nivel ${gameState.level}`);
    updateHUD();
  }
}

function updateHUD() {
  document.getElementById('level').textContent = gameState.level;
  document.getElementById('lupicoins').textContent = gameState.lupicoins;
  document.getElementById('xpCurrent').textContent = gameState.xp;
  document.getElementById('xpNeeded').textContent = gameState.xpNeeded;
  
  const xpPercent = (gameState.xp / gameState.xpNeeded) * 100;
  const xpBar = document.getElementById('xpProgress');
  if (xpBar) xpBar.style.width = `${xpPercent}%`;
  
  const powerPercent = (gameState.power / gameState.maxPower) * 100;

  const powerIndicator = document.getElementById('powerIndicator');
  if (powerIndicator) {
    if (gameState.combo > 0) {
      powerIndicator.innerHTML = `
        <div style="color: #fff; font-size: 0.9rem;">COMBO x${gameState.comboMultiplier}</div>
        <div class="power-bar">
          <div class="power-progress" style="background: linear-gradient(90deg, #ff00ff, #00ffff); width: 100%"></div>
        </div>
      `;
    } else {
      powerIndicator.innerHTML = `
        <div style="color: #fff; font-size: 0.9rem;">PODER</div>
        <div class="power-bar">
          <div class="power-progress" id="powerProgress"></div>
        </div>
      `;
      const powerBar = document.getElementById('powerProgress');
      if (powerBar) powerBar.style.width = `${powerPercent}%`;
    }
  }
}


// Actualizar UI de misi√≥n
function updateMissionUI() {
  const mission = missions[currentMissionIndex];
  if (!mission) return;
  
  document.getElementById('missionObjective').textContent = mission.objective;
  document.getElementById('missionReward').textContent = `+${mission.reward} Lupicoins`;
  
  const progressPercent = (mission.progress / mission.target) * 100;
  document.getElementById('missionProgress').style.width = `${progressPercent}%`;
}

// Mostrar notificaci√≥n
function showNotification(title, text) {
  const notification = document.getElementById('notification');
  const titleEl = document.getElementById('notificationTitle');
  const textEl = document.getElementById('notificationText');
  
  titleEl.textContent = title;
  textEl.textContent = text;
  
  notification.style.display = 'block';
  
  // Auto-ocultar despu√©s de 3 segundos
  setTimeout(() => {
    if (notification.style.display === 'block') {
      notification.style.display = 'none';
    }
  }, 3000);
}

// Ocultar notificaci√≥n
function hideNotification() {
  document.getElementById('notification').style.display = 'none';
}

// Mostrar texto flotante
function showFloatingText(text, position) {
  // Crear elemento de texto flotante
  const floatingText = document.createElement('div');
  floatingText.style.position = 'absolute';
  floatingText.style.left = '50%';
  floatingText.style.top = '40%';
  floatingText.style.transform = 'translate(-50%, -50%)';
  floatingText.style.color = '#fff';
  floatingText.style.fontSize = '1.2rem';
  floatingText.style.fontWeight = 'bold';
  floatingText.style.textShadow = '0 0 5px #000';
  floatingText.style.zIndex = '100';
  floatingText.textContent = text;
  
  document.body.appendChild(floatingText);
  
  // Animaci√≥n
  let opacity = 1;
  let yPos = 0;
  
  const animateText = () => {
    opacity -= 0.02;
    yPos -= 1;
    
    floatingText.style.opacity = opacity;
    floatingText.style.transform = `translate(-50%, calc(-50% + ${yPos}px))`;
    
    if (opacity > 0) {
      requestAnimationFrame(animateText);
    } else {
      document.body.removeChild(floatingText);
    }
  };
  
  requestAnimationFrame(animateText);
}

// Crear efecto de colecci√≥n
function createCollectEffect(position) {
  // Crear part√≠culas para el efecto
  const particleCount = 10;
  const particles = new THREE.BufferGeometry();
  const positions = new Float32Array(particleCount * 3);
  
  for (let i = 0; i < particleCount * 3; i += 3) {
    positions[i] = position.x + (Math.random() - 0.5) * 2;
    positions[i + 1] = position.y + (Math.random() - 0.5) * 2;
    positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
  }
  
  particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  
  const particleMaterial = new THREE.PointsMaterial({
    size: 0.1,
    color: 0xffd700,
    transparent: true,
    opacity: 0.8
  });
  
  const particleSystem = new THREE.Points(particles, particleMaterial);
  scene.add(particleSystem);
  
  // Animaci√≥n y eliminaci√≥n
  let life = 1.0;
  
  const animateParticles = () => {
    life -= 0.05;
    
    if (life <= 0) {
      scene.remove(particleSystem);
      return;
    }
    
    particleMaterial.opacity = life * 0.8;
    
    // Mover part√≠culas hacia arriba
    const positions = particleSystem.geometry.attributes.position.array;
    for (let i = 1; i < positions.length; i += 3) {
      positions[i] += 0.05;
    }
    particleSystem.geometry.attributes.position.needsUpdate = true;
    
    requestAnimationFrame(animateParticles);
  };
  
  requestAnimationFrame(animateParticles);
}

// Crear efecto de explosi√≥n
function createExplosionEffect(position) {
  // Similar a createCollectEffect pero con diferentes par√°metros
  // Implementaci√≥n simplificada
  cameraShake = 0.8;
}

// Crear efecto de power-up
function createPowerUpEffect(position) {
  // Implementaci√≥n simplificada
}

// Crear efecto de golpe
function createHitEffect(position) {
  // Implementaci√≥n simplificada
}

// Reproducir sonido
function playSound(type) {
  // Implementaci√≥n b√°sica con Web Audio API
  // En una implementaci√≥n real, se cargar√≠an samples de audio
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    switch(type) {
      case 'collect':
        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
        break;
      case 'hit':
        oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        break;
      case 'powerup':
        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(1000, audioContext.currentTime + 0.5);
        gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.7);
        break;
      case 'explosion':
        oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
        gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
        break;
    }
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + 1.0);
  } catch (e) {
    console.log("Error de audio:", e);
  }
}

// Alternar pausa
function togglePause() {
  gamePaused = !gamePaused;
  
  if (gamePaused) {
    showNotification("Juego Pausado", "Presiona ESC para continuar");
  } else {
    hideNotification();
  }
}

// Manejar redimensionado
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Bucle de animaci√≥n principal
function animate() {
  requestAnimationFrame(animate);
  
  const delta = clock.getDelta();
  
  if (gameStarted && !gamePaused) {
    updatePlayer(delta);
    updateCamera(delta);
    checkCollisions();
    
    // Animar objetos
    animateObjects(delta);
  }
  
  renderer.render(scene, camera);
}

// Animar objetos
function animateObjects(delta) {
  // Rotar coleccionables
  collectibles.forEach(collectible => {
    if (!collectible.userData.collected) {
      collectible.rotation.y += delta * collectible.userData.spinSpeed;
      collectible.position.y = 0.3 + Math.sin(performance.now() * 0.002) * 0.2;
    }
  });
  
  // Rotar power-ups
  powerUps.forEach(powerUp => {
    if (!powerUp.userData.collected) {
      powerUp.rotation.y += delta * 2;
      powerUp.rotation.x += delta * 1.5;
      powerUp.position.y = 0.4 + Math.sin(performance.now() * 0.003) * 0.3;
    }
  });
  
  // Animar part√≠culas ambientales
  particleSystems.forEach(particleSystem => {
    const positions = particleSystem.geometry.attributes.position.array;
    
    for (let i = 0; i < positions.length; i += 3) {
      positions[i + 1] += (Math.random() - 0.5) * 0.02;
      
      // Reiniciar posici√≥n si sale del √°rea
      if (positions[i + 1] > 20) positions[i + 1] = 0;
      if (positions[i + 1] < 0) positions[i + 1] = 20;
    }
    
    particleSystem.geometry.attributes.position.needsUpdate = true;
  });
}

// Iniciar juego
function startGame(isMobile) {
  document.getElementById('startScreen').style.display = 'none';
  gameStarted = true;
  
  // Configuraci√≥n espec√≠fica para m√≥vil
  if (isMobile) {
    document.getElementById('mobileControls').style.display = 'block';
  }
  
  // Mostrar notificaci√≥n de bienvenida
  showNotification("¬°Bienvenido a Lupi Game!", "Recolecta Lupicoins y completa misiones");
  
  // Inicializar HUD
  updateHUD();
  updateMissionUI();
}

// Configurar botones de inicio
document.getElementById('startBtn').addEventListener('click', () => {
  startGame(false);
});

document.getElementById('startBtnMobile').addEventListener('click', () => {
  startGame(true);
});

// Inicializar el juego cuando se carga la p√°gina
window.addEventListener('load', () => {
  initScene();
});
</script>
</body>
</html>